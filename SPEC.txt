===== Instruction Set =====
nop                  : No operation
mov <reg> <reg/imm8> : Load <reg/imm8> into <reg>
lda <label/imm16>    : Load either the location of <label> in memory or <imm16> in AB
stb <reg>            : Store <reg> into RAM at the address in AB
ldb <reg>            : Load from RAM at the address in AB into <reg>
push <reg/imm8>      : Push <reg/imm8> onto the stack
pop <reg>            : Pop from the stack into <reg>
add <reg> <reg/imm8> : Add <reg> and <reg/imm8> together
sub <reg> <reg/imm8> : Subtract <reg/imm8> from <reg>
mul <reg> <reg/imm8> : Multiply <reg> and <reg/imm8> together
div <reg> <reg/imm8> : Divide <reg/imm8> into <reg>
and <reg> <reg/imm8> : Bitwise AND <reg> and <reg/imm8>
or <reg> <reg/imm8>  : Bitwise OR <reg> and <reg/imm8>
not <reg>            : Bitwise AND <reg>
xor <reg> <reg/imm8> : Bitwise XOR <reg> and <reg/imm8>
cmp <reg> <reg/imm8> : Subtract <reg/imm8> from <reg>, but only update flags
jmp <reg/imm8>       : Unconditionally jump to <label/imm8>
jz <reg/imm8>        : Jump to the address in AB if <reg/imm8> sets the zero flag
jc <reg/imm8>        : Jump to the address in AB if <reg/imm8> sets the carry flag
jn <reg/imm8>        : Jump to the address in AB if <reg/imm8> sets the negative flag
hlt                  : Halt the CPU

*NOTES*:
- All ALU-based operations store the result in the first specified register
- "AB" is shorthand for a memory location in which the low byte is in register B and the high byte in register A

===== Registers =====
General Purpose (8-bit): a, b, c, d
Stack Pointer (8-bit): sp
Flags (8-bit): f
    - Zero
    - Carry
    - Negative
Program Counter (16-bit, stored in memory): pc

===== Memory Layout =====
0x0000-0x7fff: Program Memory
0x8000-0x80ff: Stack
0x8100-0xfffd: General Purpose
0xfffe-0xffff: Program Counter