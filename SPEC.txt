======================= Instruction Set =======================
0x10 -> nop          : No Operation
0x25 -> mov %r1, %r2 : Move [ r1 = r2 ]
0x26 -> mov %r, $i8  : Move [ r = i8 ]
0x3c -> lda $i16     : Load Address* [ ((ah << 8) | al) = i16 ]
0x44 -> stb %r       : Store Byte [ ((ah << 8) | al) = r ]
0x54 -> ldb %r       : Load Byte [ r = ((ah << 8) | al) ]
0x64 -> push %r      : Push to stack [ sp++ = r ]
0x74 -> pop %r       : Pop from stack [ r = --sp ]
0x85 -> add %r1, %r2 : Add [ r1 += r2 ]
0x86 -> add %r, $i8  : Add [ r += i8 ]
0x95 -> and %r1, %r2 : And [ r1 &= r2 ]
0x96 -> and %r, $i8  : And [ r &= i8 ]
0xa5 -> or %r1, %r2  : Or [ r1 |= r2 ]
0xa6 -> or %r, $i8   : Or [ r |= i8 ]
0xb4 -> not %r       : Not [ r = ~r ]
0xc5 -> cmp %r1, %r2 : Compare** [ f = r1 - r2 ]
0xc6 -> cmp %r, $i8  : Compare* [ f = r1 - i8 ]
0xd6 -> tsf %r, $i8  : Test for flag*** [ r = f & i8 ]
0xe0 -> jmp          : Jump [ pc = ((ah << 8) | al) ]
0xf0 -> jz           : Jump if Zero [ pc = ((ah << 8) | al), if f.z]

* Any label passed will be converted to its address counterpart
** Updates flag register without storing the result
*** Record the state of the provided flag index

========================== Registers ==========================
General Purpose (8-bit): a, b, c, d

Stack Pointer* (8-bit): sp

Address (8-bit): al, ah

Flags** (4-bit): f -> - Z C N
                      | | | |
                      | | | +- Negative
                      | | +--- Carry
                      | +----- Zero
                      +------- (unused)

Program Counter** (16-bit, stored in memory): pc

* Programs cannot write to, only read from
** Programs can only interact via select instructions

======================== Memory Layout ========================
0x0000-0x7fff: Program Memory
0x8000-0x80ff: Stack (LIFO)
0x8100-0xfffd: General Purpose
0xfffe-0xffff: Program Counter